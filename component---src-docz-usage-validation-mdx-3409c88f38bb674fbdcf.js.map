{"version":3,"sources":["webpack:///./src/docz/usage/validation.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"wPAQaA,G,UAAe,S,+MAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,cADR,cAGA,iBAAQ,CACN,GAAM,0BADR,0BAGA,gFACA,uBAAK,gCAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,obAYL,4HAA2G,0BAAYA,WAAW,KAAvB,YAA3G,yEACA,+FAA8E,0BAAYA,WAAW,KAAvB,+BAA9E,+FAAqP,0BAAYA,WAAW,KAAvB,aAArP,UACA,4BAAW,0BAAYA,WAAW,KAAvB,gBAAX,oDAAwH,0BAAYA,WAAW,KAAvB,YAAxH,8FAA2Q,0BAAYA,WAAW,KAAvB,gBAA3Q,0GACA,6EAA4D,0BAAYA,WAAW,KAAvB,kBAA5D,KACA,iBAAQ,CACN,GAAM,2BADR,2BAGA,iIACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0hBAeL,0GAAyF,0BAAYA,WAAW,KAAvB,WAAzF,8NACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6DAIL,oIAAmH,0BAAYA,WAAW,KAAvB,kBAAnH,KACA,iBAAQ,CACN,GAAM,0BADR,0BAGA,4LACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,sQAYL,qEAAoD,0BAAYA,WAAW,KAAvB,cAApD,4EAAuL,0BAAYA,WAAW,KAAvB,YAAvL,KACA,iBAAQ,CACN,GAAM,mCADR,qCAGA,4BAAW,kBAAIA,WAAW,KAAf,YAAX,yDAAyG,0BAAYA,WAAW,KAAvB,YAAzG,4IAA0S,0BAAYA,WAAW,KAAvB,gBAA1S,4CACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6R,6MAgBTJ,EAAWK,gBAAiB","file":"component---src-docz-usage-validation-mdx-3409c88f38bb674fbdcf.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/carsten/Entwicklung/Projekte/metro/data/mobx-binder/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"validation\"\n    }}>{`Validation`}</h1>\n    <h2 {...{\n      \"id\": \"synchronous-validation\"\n    }}>{`Synchronous validation`}</h2>\n    <p>{`For every field, we can specify validations to be done:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// for SimpleBinder\nconst minLength = (min: number) => (value?: string) =>\n    !!value && value.length < min ? \\`Please enter at least \\${min} characters\\` : undefined\n\n// or for DefaultBinder\nconst minLength = (min: number) => (value?: string) =>\n    !!value && value.length < min ? { messageKey: \\`validation.minLength', args: { value, min } } : {}\n\nbinder.forField(fullName).isRequired().withValidator(minLength(5)).bind()\n`}</code></pre>\n    <p>{`Validations are processed in order of method calls - so in this example, it is first checked if the `}<inlineCode parentName=\"p\">{`required`}</inlineCode>{` validation fails, and if it does, no further validation will happen.`}</p>\n    <p>{`To see the list of already supported validations, take a look into the `}<inlineCode parentName=\"p\">{`mobx-binder/src/validation/`}</inlineCode>{` folder. You can also easily define your own custom validator, as long as it implements the `}<inlineCode parentName=\"p\">{`Validator`}</inlineCode>{` type.`}</p>\n    <p>{`The `}<inlineCode parentName=\"p\">{`isRequired()`}</inlineCode>{` validation has the special side effect that the `}<inlineCode parentName=\"p\">{`required`}</inlineCode>{` property is set on the field, so that the rendering component can highlight it. Also, the `}<inlineCode parentName=\"p\">{`isRequired()`}</inlineCode>{` validation can be active or inactive based on a condition that can be passed as an optional argument.`}</p>\n    <p>{`Only valid field values are written to an object via `}<inlineCode parentName=\"p\">{`binder.store()`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"asynchronous-validation\"\n    }}>{`Asynchronous validation`}</h2>\n    <p>{`If validation incurs expensive calculations or a backend request, itâ€™s possible to do it asynchronously:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// for SimpleBinder\nconst uniqueTaxNumber = (value?: string) => request.get(\\`/check/taxnumber/\\${value}\\`)\n    .then(response => response.body.conflict ? 'Your company is aready registered' : undefined)\n\n// or for DefaultBinder\nconst uniqueTaxNumber = (value?: string) => request.get(\\`/check/taxnumber/\\${value}\\`)\n    .then(response => response.body.conflict ? { messageKey: \\`validation.taxNumber.conflict', args: { value } } : {})\n\nbinder\n    .forStringField(taxNumber)\n    .withAsyncValidator(uniqueTaxNumber)\n    .bind()\n`}</code></pre>\n    <p>{`In contrast to synchronous validation, the async validation expects to get back a `}<inlineCode parentName=\"p\">{`Promise`}</inlineCode>{` of the validation result. As this is a more expensive validation, it does not happen on every change of the field value, but only on submission. If you want an additional check on blur, you can configure this like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`.withAsyncValidator(uniqueTaxNumber, { onBlur: true })\n`}</code></pre>\n    <p>{`Only field values where asynchronous validation has been successfully finished are written to an object via `}<inlineCode parentName=\"p\">{`binder.store()`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"conditional-validation\"\n    }}>{`Conditional validation`}</h2>\n    <p>{`Sometimes, the validation of one field depends on the value of another field. Given the data used to evaluate the condition is observable, there is not much to do:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`public salutation = new TextField('salutation')\npublic fullName = new TextField('fullName')\n\nbinder\n    .forStringField(salutation)\n    .bind()\n    .forField(fullName)\n        .withValidator(someValidatorDependingOnValueOf(salutation))\n    .bind()\n`}</code></pre>\n    <p>{`In this example, changes to the value of the `}<inlineCode parentName=\"p\">{`salutation`}</inlineCode>{` field will automatically trigger a re-evaluation of the validity of the `}<inlineCode parentName=\"p\">{`fullName`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"conditional-required-validation\"\n    }}>{`Conditional \"required\" validation`}</h2>\n    <p>{`The `}<em parentName=\"p\">{`required`}</em>{` validation is a special case, as it also affects the `}<inlineCode parentName=\"p\">{`required`}</inlineCode>{` property at field level, which you most probably want to use to mark fields as optional or required in their labels. For this case, the `}<inlineCode parentName=\"p\">{`isRequired()`}</inlineCode>{` method supports an additional callback:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`public salutation = new TextField('salutation')\npublic fullName = new TextField('fullName')\n\nbinder\n    .forStringField(salutation)\n    .bind()\n    .forField(fullName)\n    .isRequired(undefined /* use default i18n error key */, () => !salutation.value)\n    .bind()\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
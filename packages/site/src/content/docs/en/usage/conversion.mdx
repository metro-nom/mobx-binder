---
title: Conversion
---

## Synchronous conversion

As with validators, converters can also be added to the binding chain:

``` typescript
import { MomentConverter, MomentValidators } from 'mobx-binder-moment'
...
binder.forStringField(fullName)
    .isRequired()
    .withConverter(new MomentConverter('DD.MM.YYYY'))
    .withValidator(Validators.dayInPast())
    .bind()
```

Converters have to fulfill the following interface:

``` typescript
interface Converter<_ValidationResult, ViewType, ModelType> {
    convertToModel(value: ViewType): ModelType
    convertToPresentation(data: ModelType): ViewType
    isEqual?(first: ModelType, second: ModelType): boolean
}
```

A conversion is only tried if previous validations succeeded. A converter may fail if the value is not convertible, which means that Converters also act as validators.

Validators that are added after a converter will act on the already converted value. The API of Binder makes use of TypeScript generics to make sure that a Validator can only be applied to a matching data type.

Converters are bidirectional - that means that on loading values into the form, they are converted back into a string representation. Also, when a to-model conversion has been successful, the resulting value is passed back to `convertToPresentation` and the rendered field value is updated.

When a simple equality check via `===` for the converted ModelType is not sufficient, the converter also has to implement `isEqual`. This is required for the `changed` property and other internal optimizations.

Please not that by default empty string field values are not any more converted automatically to `undefined`. Instead, one can use `binder.forField().withStringOrUndefined()` or simply `binder.forStringField()` to configure the same behaviour explicitly.

## Asynchronous conversion

As for the async validation, there might be cases where a conversion is done remotely and needs to be asynchronous. One example could be to contact some external service that validates phone numbers and also brings these numbers into some common format.

``` typescript
binder
    .forStringField(fullName)
    .withAsyncConverter(verifyAndPrettifyPhoneNumberConverter)
    .bind()
```

Asynchronous converters have to fullfill the following interface:

``` typescript
interface AsyncConverter<_ValidationResult, ViewType, ModelType> {
    convertToModel(value: ViewType): Promise<ModelType>
    convertToPresentation(data: ModelType): ViewType
    isEqual?(first: ModelType, second: ModelType): boolean
}
```

The `convertToModel` method then is expected to return the validation result or reject with a `ValidationError`. As with the async validation, this does not happen on every change of the field value, but only on submission. If you want an additional check on blur, you can configure this like so:

``` typescript
.withAsyncValidator(myAsyncValidator, { onBlur: true })
```

When the conversion has been successful, the resulting value is passed back to `convertToPresentation` and the rendered field value is updated.

Only field values where asynchronous conversion has been successfully finished are written to an object via `binder.store()`.

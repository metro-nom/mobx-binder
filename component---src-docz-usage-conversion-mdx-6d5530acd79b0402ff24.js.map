{"version":3,"sources":["webpack:///./src/docz/usage/conversion.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"wPAQaA,G,UAAe,S,+MAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,cADR,cAGA,iBAAQ,CACN,GAAM,0BADR,0BAGA,+FACA,uBAAK,gCAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,sPAUL,4EACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,yOAQL,gMACA,2OACA,0PAAyO,0BAAYA,WAAW,KAAvB,yBAAzO,6CACA,yDAAwC,0BAAYA,WAAW,KAAvB,OAAxC,uFAA+K,0BAAYA,WAAW,KAAvB,WAA/K,8BAAiQ,0BAAYA,WAAW,KAAvB,WAAjQ,+CACA,yHAAwG,0BAAYA,WAAW,KAAvB,aAAxG,0BAAwL,0BAAYA,WAAW,KAAvB,6CAAxL,cAA4R,0BAAYA,WAAW,KAAvB,2BAA5R,gDACA,iBAAQ,CACN,GAAM,2BADR,2BAGA,sRACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,yHAOL,0FACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uPAQL,4BAAW,0BAAYA,WAAW,KAAvB,kBAAX,6EAAmJ,0BAAYA,WAAW,KAAvB,mBAAnJ,6LACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,8DAIL,uGAAsF,0BAAYA,WAAW,KAAvB,yBAAtF,6CACA,oIAAmH,0BAAYA,WAAW,KAAvB,kBAAnH,W,6MAKJJ,EAAWK,gBAAiB","file":"component---src-docz-usage-conversion-mdx-6d5530acd79b0402ff24.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/carsten/Entwicklung/Projekte/metro/data/mobx-binder/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"conversion\"\n    }}>{`Conversion`}</h1>\n    <h2 {...{\n      \"id\": \"synchronous-conversion\"\n    }}>{`Synchronous conversion`}</h2>\n    <p>{`As with validators, converters can also be added to the binding chain:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { MomentConverter, MomentValidators } from 'mobx-binder-moment'\n...\nbinder.forStringField(fullName)\n    .isRequired()\n    .withConverter(new MomentConverter('DD.MM.YYYY'))\n    .withValidator(Validators.dayInPast())\n    .bind()\n`}</code></pre>\n    <p>{`Converters have to fulfill the following interface:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface Converter<_ValidationResult, ViewType, ModelType> {\n    convertToModel(value: ViewType): ModelType\n    convertToPresentation(data: ModelType): ViewType\n    isEqual?(first: ModelType, second: ModelType): boolean\n}\n`}</code></pre>\n    <p>{`A conversion is only tried if previous validations succeeded. A converter may fail if the value is not convertible, which means that Converters also act as validators.`}</p>\n    <p>{`Validators that are added after a converter will act on the already converted value. The API of Binder makes use of TypeScript generics to make sure that a Validator can only be applied to a matching data type.`}</p>\n    <p>{`Converters are bidirectional - that means that on loading values into the form, they are converted back into a string representation. Also, when a to-model conversion has been successful, the resulting value is passed back to `}<inlineCode parentName=\"p\">{`convertToPresentation`}</inlineCode>{` and the rendered field value is updated.`}</p>\n    <p>{`When a simple equality check via `}<inlineCode parentName=\"p\">{`===`}</inlineCode>{` for the converted ModelType is not sufficient, the converter also has to implement `}<inlineCode parentName=\"p\">{`isEqual`}</inlineCode>{`. This is required for the `}<inlineCode parentName=\"p\">{`changed`}</inlineCode>{` property and other internal optimizations.`}</p>\n    <p>{`Please not that by default empty string field values are not any more converted automatically to `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`. Instead, one can use `}<inlineCode parentName=\"p\">{`binder.forField().withStringOrUndefined()`}</inlineCode>{` or simply `}<inlineCode parentName=\"p\">{`binder.forStringField()`}</inlineCode>{` to configure the same behaviour explicitly.`}</p>\n    <h2 {...{\n      \"id\": \"asynchronous-conversion\"\n    }}>{`Asynchronous conversion`}</h2>\n    <p>{`As for the async validation, there might be cases where a conversion is done remotely and needs to be asynchronous. One example could be to contact some external service that validates phone numbers and also brings these numbers into some common format.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`binder\n    .forStringField(fullName)\n    .withAsyncConverter(verifyAndPrettifyPhoneNumberConverter)\n    .bind()\n`}</code></pre>\n    <p>{`Asynchronous converters have to fullfill the following interface:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`interface AsyncConverter<_ValidationResult, ViewType, ModelType> {\n    convertToModel(value: ViewType): Promise<ModelType>\n    convertToPresentation(data: ModelType): ViewType\n    isEqual?(first: ModelType, second: ModelType): boolean\n}\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`convertToModel`}</inlineCode>{` method then is expected to return the validation result or reject with a `}<inlineCode parentName=\"p\">{`ValidationError`}</inlineCode>{`. As with the async validation, this does not happen on every change of the field value, but only on submission. If you want an additional check on blur, you can configure this like so:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`.withAsyncValidator(myAsyncValidator, { onBlur: true })\n`}</code></pre>\n    <p>{`When the conversion has been successful, the resulting value is passed back to `}<inlineCode parentName=\"p\">{`convertToPresentation`}</inlineCode>{` and the rendered field value is updated.`}</p>\n    <p>{`Only field values where asynchronous conversion has been successfully finished are written to an object via `}<inlineCode parentName=\"p\">{`binder.store()`}</inlineCode>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
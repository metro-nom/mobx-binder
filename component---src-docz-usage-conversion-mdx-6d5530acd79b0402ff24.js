(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{zY7O:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return l})),t.d(n,"default",(function(){return d}));var o=t("cxan"),a=t("+wNj"),r=(t("ERkP"),t("ZVZ0")),i=t("9Rvw"),l=(t("l1C2"),{});void 0!==l&&l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"src/docz/usage/conversion.mdx"}});var s={_frontmatter:l},c=i.a;function d(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)(c,Object(o.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("h1",{id:"conversion"},"Conversion"),Object(r.b)("h2",{id:"synchronous-conversion"},"Synchronous conversion"),Object(r.b)("p",null,"As with validators, converters can also be added to the binding chain:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"import { MomentConverter, MomentValidators } from 'mobx-binder-moment'\n...\nbinder.forStringField(fullName)\n    .isRequired()\n    .withConverter(new MomentConverter('DD.MM.YYYY'))\n    .withValidator(Validators.dayInPast())\n    .bind()\n")),Object(r.b)("p",null,"Converters have to fulfill the following interface:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"interface Converter<_ValidationResult, ViewType, ModelType> {\n    convertToModel(value: ViewType): ModelType\n    convertToPresentation(data: ModelType): ViewType\n    isEqual?(first: ModelType, second: ModelType): boolean\n}\n")),Object(r.b)("p",null,"A conversion is only tried if previous validations succeeded. A converter may fail if the value is not convertible, which means that Converters also act as validators."),Object(r.b)("p",null,"Validators that are added after a converter will act on the already converted value. The API of Binder makes use of TypeScript generics to make sure that a Validator can only be applied to a matching data type."),Object(r.b)("p",null,"Converters are bidirectional - that means that on loading values into the form, they are converted back into a string representation. Also, when a to-model conversion has been successful, the resulting value is passed back to ",Object(r.b)("inlineCode",{parentName:"p"},"convertToPresentation")," and the rendered field value is updated."),Object(r.b)("p",null,"When a simple equality check via ",Object(r.b)("inlineCode",{parentName:"p"},"===")," for the converted ModelType is not sufficient, the converter also has to implement ",Object(r.b)("inlineCode",{parentName:"p"},"isEqual"),". This is required for the ",Object(r.b)("inlineCode",{parentName:"p"},"changed")," property and other internal optimizations."),Object(r.b)("p",null,"Please not that by default empty string field values are not any more converted automatically to ",Object(r.b)("inlineCode",{parentName:"p"},"undefined"),". Instead, one can use ",Object(r.b)("inlineCode",{parentName:"p"},"binder.forField().withStringOrUndefined()")," or simply ",Object(r.b)("inlineCode",{parentName:"p"},"binder.forStringField()")," to configure the same behaviour explicitly."),Object(r.b)("h2",{id:"asynchronous-conversion"},"Asynchronous conversion"),Object(r.b)("p",null,"As for the async validation, there might be cases where a conversion is done remotely and needs to be asynchronous. One example could be to contact some external service that validates phone numbers and also brings these numbers into some common format."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"binder\n    .forStringField(fullName)\n    .withAsyncConverter(verifyAndPrettifyPhoneNumberConverter)\n    .bind()\n")),Object(r.b)("p",null,"Asynchronous converters have to fullfill the following interface:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),"interface AsyncConverter<_ValidationResult, ViewType, ModelType> {\n    convertToModel(value: ViewType): Promise<ModelType>\n    convertToPresentation(data: ModelType): ViewType\n    isEqual?(first: ModelType, second: ModelType): boolean\n}\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"convertToModel")," method then is expected to return the validation result or reject with a ",Object(r.b)("inlineCode",{parentName:"p"},"ValidationError"),". As with the async validation, this does not happen on every change of the field value, but only on submission. If you want an additional check on blur, you can configure this like so:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-typescript"}),".withAsyncValidator(myAsyncValidator, { onBlur: true })\n")),Object(r.b)("p",null,"When the conversion has been successful, the resulting value is passed back to ",Object(r.b)("inlineCode",{parentName:"p"},"convertToPresentation")," and the rendered field value is updated."),Object(r.b)("p",null,"Only field values where asynchronous conversion has been successfully finished are written to an object via ",Object(r.b)("inlineCode",{parentName:"p"},"binder.store()"),"."))}void 0!==d&&d&&d===Object(d)&&Object.isExtensible(d)&&!d.hasOwnProperty("__filemeta")&&Object.defineProperty(d,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"src/docz/usage/conversion.mdx"}}),d.isMDXComponent=!0}}]);
//# sourceMappingURL=component---src-docz-usage-conversion-mdx-6d5530acd79b0402ff24.js.map